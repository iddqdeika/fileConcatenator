
\handlers.go:
{
package core

import (
	"fileProcessor/definition"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

var filesCreated = make(map[string]struct{})

func FileConcatenator(outputFileName string) definition.Handler{
	return func(path string) {
		data, err := ioutil.ReadFile(path)
		if err != nil{
			fmt.Printf("cant read file %v, err: %v", path, err)
			return
		}
		fname := path[strings.LastIndex(path, string(os.PathSeparator)):]
		err = appendFile(outputFileName, fname, data)
		if err != nil{
			fmt.Printf("cant write to file %v, err: %v", outputFileName, err)
			return
		}
	}
}

func appendFile(outputFileName string, filename string, data []byte) error{
	if _, ok := filesCreated[outputFileName]; !ok{
		_, err := os.Create(outputFileName)
		if err != nil{
			return fmt.Errorf("cant create file %v, err: %v", outputFileName, err)
		}
		filesCreated[outputFileName] = struct{}{}
	}
	f, err := os.OpenFile(outputFileName, os.O_APPEND, os.ModeAppend)
	if err != nil{
		return fmt.Errorf("cant open file %v, err: %v\r\n", outputFileName, err)
	}
	defer f.Close()

	_, err = f.Write([]byte("\r\n" + filename + ":\r\n{\r\n"))
	if err != nil{
		return fmt.Errorf("cant write file %v, err: %v\r\n", outputFileName, err)
	}

	_, err = f.Write(data)
	if err != nil{
		return fmt.Errorf("cant write file %v, err: %v\r\n", outputFileName, err)
	}

	_, err = f.Write([]byte("\r\n}\r\n"))
	if err != nil{
		return fmt.Errorf("cant write file %v, err: %v\r\n", outputFileName, err)
	}
	return nil
}
}

\recursiveFileProcessor.go:
{
package core

import (
	"fileProcessor/definition"
	"fmt"
	"os"
)

type dispatcher struct{
	validate definition.Validator
	handle   definition.Handler
}

func NewRecursiveProcessor() definition.Processor{
	return &recursiveProcessor{}
}

type recursiveProcessor struct {
	dispatchers []*dispatcher
}

func (p *recursiveProcessor) WithHandler(validator definition.Validator, handler definition.Handler) definition.Processor {
	if validator == nil || handler == nil{
		return p
	}
	p.dispatchers = append(p.dispatchers, &dispatcher{
		validate: validator,
		handle:   handler,
	})
	return p
}

func (p *recursiveProcessor) ProcessPath(path string) error {
	return p.process(path)
}

func (p *recursiveProcessor) process(path string) error{
	f, err := os.Open(path)
	if err != nil{
		return fmt.Errorf("(path=%v) cant open file, err: %v", path, err)
	}
	s, err := f.Stat()
	if err != nil{
		return fmt.Errorf("(path=%v) cant get file/dir stat, err: %v", path, err)
	}
	if s.IsDir(){
		names, err := f.Readdirnames(0)
		if err != nil{
			return fmt.Errorf("(path=%v) cant get dirnames, err: %v", path, err)
		}
		for _, name := range names {
			p.process(path + string(os.PathSeparator) + name)
		}
	}
	p.dispatch(path)
	return nil
}

func (p *recursiveProcessor) dispatch(path string) {
	for _, d := range p.dispatchers {
		if d.validate(path){
			d.handle(path)
		}
	}
}

}

\validators.go:
{
package core

import (
	"fileProcessor/definition"
	"strings"
)

func ExtensionListValidator(extensions []string) definition.Validator{
	if extensions == nil || len(extensions)==0 || extensions[0]==""{
		return nil
	}
	return func(path string) (ok bool) {
		for _, ext := range extensions {
			if strings.HasSuffix(path, strings.Trim(ext, "\t ")){
				return true
			}
		}
		return false
	}
}
}

\definition.go:
{
package definition

type Validator func(path string)(ok bool)

type Handler func(path string)

type Processor interface {
	WithHandler(validator Validator, handler Handler) Processor
	ProcessPath(path string) error
}
}

\main.go:
{
package main

import (
	"fileProcessor/core"
	"fmt"
	"os"
	"strings"
)

const extensionsArgPrefix = "extensions="

func main(){

	var extensions []string
	for _, arg:= range os.Args {
		if strings.HasPrefix(arg,extensionsArgPrefix){
			extensions = strings.Split(strings.TrimLeft(arg, extensionsArgPrefix), ";")
			fmt.Printf("extension list set: %v\r\n", extensions)
		}
	}

	//defaultValidator := func(path string) (ok bool) {
	//	return true
	//}
	//defaultHandler := func(path string) {
	//	fmt.Println(path)
	//}

	core.
		NewRecursiveProcessor().
		WithHandler(core.ExtensionListValidator(extensions), core.FileConcatenator("out.txt")).
		ProcessPath("C:\\Users\\User\\go\\src\\fileProcessor")
}
}
